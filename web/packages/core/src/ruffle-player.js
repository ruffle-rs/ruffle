const load_ruffle = require("./load-ruffle");
const ruffle_shadow_template = require("./shadow-template");
const { lookup_element } = require("./register-element");

exports.FLASH_MIMETYPE = "application/x-shockwave-flash";
exports.FUTURESPLASH_MIMETYPE = "application/futuresplash";
exports.FLASH7_AND_8_MIMETYPE = "application/x-shockwave-flash2-preview";
exports.FLASH_MOVIE_MIMETYPE = "application/vnd.adobe.flash-movie";
exports.FLASH_ACTIVEX_CLASSID = "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000";

const DIMENSION_REGEX = /^\s*(\d+(\.\d+)?(%)?)/;

function sanitize_parameters(parameters) {
    if (parameters === null || parameters === undefined) {
        return {};
    }
    if (!(parameters instanceof URLSearchParams)) {
        parameters = new URLSearchParams(parameters);
    }
    const output = {};

    for (const [key, value] of parameters) {
        // Every value must be type of string
        output[key] = value.toString();
    }

    return output;
}

exports.RufflePlayer = class RufflePlayer extends HTMLElement {
    constructor(...args) {
        let self = super(...args);

        self.shadow = self.attachShadow({ mode: "closed" });
        self.shadow.appendChild(ruffle_shadow_template.content.cloneNode(true));

        self.dynamic_styles = self.shadow.getElementById("dynamic_styles");
        self.container = self.shadow.getElementById("container");
        self.play_button = self.shadow.getElementById("play_button");
        if (self.play_button) {
            self.play_button.addEventListener(
                "click",
                self.play_button_clicked.bind(self)
            );
        }
        self.right_click_menu = self.shadow.getElementById("right_click_menu");

        self.addEventListener(
            "contextmenu",
            self.open_right_click_menu.bind(self)
        );

        self.addEventListener("click", self.hide_right_click_menu.bind(self));

        self.instance = null;
        self.allow_script_access = false;
        self._trace_observer = null;

        self.Ruffle = load_ruffle();

        return self;
    }

    connectedCallback() {
        this.update_styles();
    }

    static get observedAttributes() {
        return ["width", "height"];
    }

    attributeChangedCallback(name) {
        if (name === "width" || name === "height") {
            this.update_styles();
        }
    }

    disconnectedCallback() {
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
            console.log("Ruffle instance destroyed.");
        }
    }

    update_styles() {
        if (this.dynamic_styles.sheet) {
            if (this.dynamic_styles.sheet.rules) {
                for (
                    var i = 0;
                    i < this.dynamic_styles.sheet.rules.length;
                    i++
                ) {
                    this.dynamic_styles.sheet.deleteRule(i);
                }
            }

            if (this.attributes.width) {
                let width = RufflePlayer.html_dimension_to_css_dimension(
                    this.attributes.width.value
                );
                if (width !== null) {
                    this.dynamic_styles.sheet.insertRule(
                        `:host { width: ${width}; }`
                    );
                }
            }

            if (this.attributes.height) {
                let height = RufflePlayer.html_dimension_to_css_dimension(
                    this.attributes.height.value
                );
                if (height !== null) {
                    this.dynamic_styles.sheet.insertRule(
                        `:host { height: ${height}; }`
                    );
                }
            }
        }
    }

    /**
     * Determine if this element is the fallback content of another Ruffle
     * player.
     *
     * This heurustic assumes Ruffle objects will never use their fallback
     * content. If this changes, then this code also needs to change.
     */
    is_unused_fallback_object() {
        let parent = this.parentNode;
        let element = lookup_element("ruffle-object");

        if (element !== null) {
            do {
                if (parent.nodeName === element.name) {
                    return true;
                }

                parent = parent.parentNode;
            } while (parent != document);
        }

        return false;
    }

    /**
     * Ensure a fresh Ruffle instance is ready on this player before continuing.
     *
     * @throws Any exceptions generated by loading Ruffle Core will be logged
     * and passed on.
     */
    async ensure_fresh_instance() {
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
            console.log("Ruffle instance destroyed.");
        }

        let Ruffle = await this.Ruffle.catch((e) => {
            console.error("Serious error loading Ruffle: " + e);

            // Serious duck typing. In error conditions, let's not make assumptions.
            const message =
                e && e.message ? String(e.message).toLowerCase() : "";
            if (message.indexOf("MIME") >= 0) {
                this.panicked = true;
                this.container.innerHTML = `
                    <div id="panic">
                        <div id="panic-title">Something went wrong :(</div>
                        <div id="panic-body">
                            <p>Ruffle has encountered a major issue whilst trying to initialize.</p>
                            <p>This web server is either not serving ".wasm" files with the correct MIME type, or the file cannot be found.</p>
                            <p>If you are the server administrator, please consult the Ruffle wiki for help.</p>
                        </div>
                        <div id="panic-footer">
                            <ul>
                                <li><a href="https://github.com/ruffle-rs/ruffle/wiki/Using-Ruffle#configure-wasm-mime-type">view Ruffle wiki</a></li>
                            </ul>
                        </div>
                    </div>
                `;
            }
            throw e;
        });

        this.instance = Ruffle.new(
            this.container,
            this,
            this.allow_script_access
        );
        console.log("New Ruffle instance created.");
    }

    /**
     * Load a movie into this Ruffle Player instance by URL.
     *
     * Any existing movie will be immediately stopped, while the new movie's
     * load happens asynchronously. There is currently no way to await the file
     * being loaded, or any errors that happen loading it.
     *
     * @param {String} url The URL to stream.
     * @param {URLSearchParams|String|Object} [parameters] The parameters (also known as "flashvars") to load the movie with.
     * If it's a string, it will be decoded into an object.
     * If it's an object, every key and value must be a String.
     * These parameters will be merged onto any found in the query portion of the swf URL.
     */
    async stream_swf_url(url, parameters) {
        //TODO: Actually stream files...
        try {
            if (this.isConnected && !this.is_unused_fallback_object()) {
                console.log("Loading SWF file " + url);

                await this.ensure_fresh_instance();
                parameters = {
                    ...sanitize_parameters(url.substring(url.indexOf("?"))),
                    ...sanitize_parameters(parameters),
                };
                this.instance.stream_from(url, parameters);

                if (this.play_button) {
                    this.play_button.style.display = "block";
                }
            } else {
                console.warn(
                    "Ignoring attempt to play a disconnected or suspended Ruffle element"
                );
            }
        } catch (err) {
            console.error("Serious error occurred loading SWF file: " + err);
            this.panic(err);
            throw err;
        }
    }

    play_button_clicked() {
        if (this.instance) {
            this.instance.play();
            if (this.play_button) {
                this.play_button.style.display = "none";
            }
        }
    }

    open_right_click_menu(e) {
        const rect = this.getBoundingClientRect();

        this.right_click_menu.style.display = "block";
        this.right_click_menu.style.left = Math.ceil(e.clientX - rect.x) + "px";
        this.right_click_menu.style.top = Math.ceil(e.clientY - rect.y) + "px";
        e.preventDefault();

        this.right_click_menu.innerHTML = "";

        // TODO: Loop through each item and create an appropriate element with appropriate callback here

        const element = document.createElement("li");
        element.className = "menu_item active";
        element.innerText = `About Ruffle ${window.RufflePlayer.version}`;
        element.addEventListener("click", () => {
            window.open("https://ruffle.rs", "_blank");
        });
        this.right_click_menu.appendChild(element);
    }

    hide_right_click_menu() {
        this.right_click_menu.style.display = "none";
    }

    pause() {
        if (this.instance) {
            this.instance.pause();
            if (this.play_button) {
                this.play_button.style.display = "block";
            }
        }
    }

    /**
     * Load a movie's data into this Ruffle Player instance.
     *
     * Any existing movie will be immediately stopped, and the new movie's data
     * placed into a fresh Stage on the same stack.
     *
     * Please note that by doing this, no URL information will be provided to
     * the movie being loaded.
     *
     * @param {String} url The URL to stream.
     * @param {URLSearchParams|String|Object} [parameters] The parameters (also known as "flashvars") to load the movie with.
     * If it's a string, it will be decoded into an object.
     * If it's an object, every key and value must be a String.
     */
    async play_swf_data(data, parameters) {
        try {
            if (this.isConnected && !this.is_unused_fallback_object()) {
                console.log("Got SWF data");

                await this.ensure_fresh_instance();
                this.instance.load_data(
                    new Uint8Array(data),
                    sanitize_parameters(parameters)
                );
                console.log("New Ruffle instance created.");

                if (this.play_button) {
                    this.play_button.style.display = "block";
                }
            } else {
                console.warn(
                    "Ignoring attempt to play a disconnected or suspended Ruffle element"
                );
            }
        } catch (err) {
            console.error("Serious error occurred loading SWF file: " + err);
            this.panic(err);
            throw err;
        }
    }

    /*
     * Copies attributes and children from another element to this player element.
     * Used by the polyfill elements, RuffleObject and RuffleEmbed.
     */
    copy_element(elem) {
        if (elem) {
            for (let attrib of elem.attributes) {
                if (attrib.specified) {
                    // Issue 468: Chrome "Click to Active Flash" box stomps on title attribute
                    if (
                        attrib.name === "title" &&
                        attrib.value === "Adobe Flash Player"
                    ) {
                        continue;
                    }

                    try {
                        this.setAttribute(attrib.name, attrib.value);
                    } catch (err) {
                        // The embed may have invalid attributes, so handle these gracefully.
                        console.warn(
                            `Unable to set attribute ${attrib.name} on Ruffle instance`
                        );
                    }
                }
            }

            for (let node of Array.from(elem.children)) {
                this.appendChild(node);
            }
        }
    }

    /*
     * Converts a dimension attribute on an HTML embed/object element to a valid CSS dimension.
     * HTML element dimensions are unitless, but can also be percentages.
     * Add a 'px' unit unless the value is a percentage.
     * Returns null if this is not a valid dimension.
     */
    static html_dimension_to_css_dimension(attribute) {
        if (attribute) {
            let match = attribute.match(DIMENSION_REGEX);
            if (match) {
                let out = match[1];
                if (!match[3]) {
                    // Unitless -- add px for CSS.
                    out += "px";
                }
                return out;
            }
        }
        return null;
    }

    /*
     * When a movie presents a new callback through `ExternalInterface.addCallback`,
     * we are informed so that we can expose the method on any relevant DOM element.
     */
    on_callback_available(name) {
        const instance = this.instance;
        this[name] = (...args) => {
            return instance.call_exposed_callback(name, args);
        };
    }

    /*
     * Sets a trace observer on this flash player.
     *
     * The observer will be called, as a function, for each message that the playing movie will "trace" (output).
     */
    set trace_observer(observer) {
        this.instance.set_trace_observer(observer);
    }

    /*
     * Panics this specific player, forcefully destroying all resources and displays an error message to the user.
     *
     * This should be called when something went absolutely, incredibly and disastrously wrong and there is no chance
     * of recovery.
     *
     * Ruffle will attempt to isolate all damage to this specific player instance, but no guarantees can be made if there
     * was a core issue which triggered the panic. If Ruffle is unable to isolate the cause to a specific player, then
     * all players will panic and Ruffle will become "poisoned" - no more players will run on this page until it is
     * reloaded fresh.
     */
    panic(error) {
        if (this.panicked) {
            // Only show the first major error, not any repeats - they aren't as important
            return;
        }
        this.panicked = true;

        // Clears out any existing content (ie play button or canvas) and replaces it with the error screen
        this.container.innerHTML = `
            <div id="panic">
                <div id="panic-title">Something went wrong :(</div>
                <div id="panic-body">
                    <p>Ruffle has encountered a major issue whilst trying to display this Flash content.</p>
                    <p>This isn't supposed to happen, so we'd really appreciate if you could file a bug!</p>
                </div>
                <div id="panic-footer">
                    <ul>
                        <li><a href="https://github.com/ruffle-rs/ruffle/issues/new">report bug</a></li>
                        <li><a href="#" id="panic-view-details">view error details</a></li>
                    </ul>
                </div>
            </div>
        `;
        this.container.querySelector("#panic-view-details").onclick = () => {
            let error_text = "# Error Info\n";

            if (error instanceof Error) {
                error_text += `Error name: ${error.name}\n`;
                error_text += `Error message: ${error.message}\n`;
                if (error.stack) {
                    error_text += `Error stack:\n\`\`\`\n${error.stack}\n\`\`\`\n`;
                }
            } else {
                error_text += `Error: ${error}\n`;
            }

            error_text += "\n# Player Info\n";
            error_text += this.debug_player_info();

            error_text += "\n# Page Info\n";
            error_text += `Page URL: ${document.location.href}\n`;

            error_text += "\n# Browser Info\n";
            error_text += `Useragent: ${window.navigator.userAgent}\n`;
            error_text += `OS: ${window.navigator.platform}\n`;

            error_text += "\n# Ruffle Info\n";
            error_text += `Ruffle version: ${window.RufflePlayer.version}\n`;
            error_text += `Ruffle source: ${window.RufflePlayer.name}\n`;
            this.container.querySelector(
                "#panic-body"
            ).innerHTML = `<textarea>${error_text}</textarea>`;
            return false;
        };

        // Do this last, just in case it causes any cascading issues.
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
        }
    }

    debug_player_info() {
        return `Allows script access: ${this.allow_script_access}\n`;
    }
};

/*
 * Returns whether the given filename ends in an "swf" extension.
 */
exports.is_swf_filename = function is_swf_filename(filename) {
    return (
        filename &&
        typeof filename === "string" &&
        (filename.search(/\.swf(?:[?#]|$)/i) >= 0 ||
            filename.search(/\.spl(?:[?#]|$)/i) >= 0)
    );
};
